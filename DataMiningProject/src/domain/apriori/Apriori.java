package domain.apriori;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class Apriori {
    
    private List<HashTree> hashTrees;
    
    private static Apriori apriori; // singleton
    
    private Apriori() {
    }
    
    public static Apriori getApriori() {
        if (apriori == null)
            apriori = new Apriori();
        return apriori;
    }
    
    /**
     * Runs the Apriori algorithm on the given set of transactions.
     * @param transactions The transactions to run the algorithm against.
     * @param absoluteMinSupport The minimum number of occurrences an itemset needs to be considered frequent.
     * @param maxBucketSize The maximum number of itemsets a bucket node in a hash tree can have before it
     *        is converted to a hash node, assuming the last level has not been reached.
     * @param childrenPerNode Each node in the generated hash trees will have this many child nodes.
     */
    public void run(Set<ItemSet> transactions, int absoluteMinSupport,
            int maxBucketSize, int childrenPerNode) {
        HashTree k_1_Itemsets;
        HashTree k_Itemsets;
        hashTrees = new ArrayList<HashTree>();
        
        /* count the occurrences of all 1-itemsets in transactions, creating C_1,
         * the set of candidate 1-itemsets. Then remove candidates that do not meet
         * minimum support to create L_1, the set of frequent 1-itemsets. */
        k_Itemsets = new HashTree(1, absoluteMinSupport, maxBucketSize, childrenPerNode);
        k_Itemsets.addAll(transactions);
        k_Itemsets.incFrequencies();
        k_Itemsets.removeNoMinSupport();
        
        while (!k_Itemsets.isEmpty()) {
            hashTrees.add(k_Itemsets);
            System.out.println(k_Itemsets.toString());
            k_1_Itemsets = k_Itemsets;
            
            // join L_(k-1) with itself and prune resulting k-itemset hash tree to create C_k
            k_Itemsets = k_1_Itemsets.generateNextCandidateTree();
            k_Itemsets.prune(k_1_Itemsets);
            
            // create L_k by counting candidate k-itemsets and removing those that don't meet minimum support
            k_Itemsets.countCandidates(transactions);
            k_Itemsets.removeNoMinSupport();
        }
    }
    
    /** @return A list of frequent k-itemsets (i.e. frequent itemsets of length k) **/
    public List<ItemSet> getFrequentKItemSets(int k) {
        List<ItemSet> itemSets = new ArrayList<ItemSet>();
        itemSets.addAll(this.hashTrees.get(k-1).toArray()); // k-itemset tree is at index k-1
        return itemSets;
    }
    
    /** @return A list of all frequent itemsets of any length **/
    public List<ItemSet> getAllFrequentItemSets() {
        List<ItemSet> itemSets = new ArrayList<ItemSet>();
        
        for (HashTree tree : hashTrees)
            itemSets.addAll(tree.toArray());
        
        return itemSets;
    }
    
    /** @return A sorted list of all hash trees (containing frequent itemsets) generated by the algorithm. **/
    public List<HashTree> getHashTrees() {
        if (hashTrees == null)
            throw new RuntimeException("The algorithm must be run before the hash trees can be accessed.");
        return hashTrees;
    }

}
